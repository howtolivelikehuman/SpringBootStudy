## 9. 빈 스코프

스프링 컨테이너의 시작과 함께 생성 - 종료될때 유지 -> 싱글톤 스코프



* 싱글톤 : 기본, 컨테이너 시작과 종료까지 유지 (가장 넓음)
* 프로토 타입 : 컨테이너는 프로토타입 빈 생성, 의존관계 주입까지만 관여 -> 그뒤에는 관리 X
* 웹 관련
  * request : 웹 요청이 들어오고 나갈때 까지
  * session : 웹 세션이 생성되고 종료될 때 까지
  * application : 웹의 서블릿 컨텍스와 같은 범위



#### 프로토타입 스코프

프로토타입 스코프는 스프링 컨테이너가 항상 새로운 인스턴스 생성-반환



[싱글톤 빈 요청]

1. 싱글톤 스코프 빈 스프링 컨테이너에 요청
2. 스프링 컨테이너는 자기가 관리하는 스프링 빈 반환
3. 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈 반환



[프로토타입 빈 요청]

1. 프로토타입 스코프 빈 컨테이너에 요청
2. 컨테이너가 프로토타입 빈 생성, 의존관계 주입
3. 생성한거 클라이언트에 반환
4. 같은 요청이 오면 위 과정을 반복



컨테이너는 프로토타입 빈 생성, 의존관계 주입, 초기화 까지만 딱 관여-> @PreDestroy같은 종료 메소드 호출 X



#### 프로토타입 스코프 - 싱글톤 빈과 같이 쓰면 문제점

<스프링 컨테이너에 프로토타입 빈을 직접 요청하는 경우>

> 1. A가 스프링 컨테이너에 프로토타입 빈을 요청
> 2. 컨테이너는 프로토타입 빈을 새로 생성해서 반환 (x01), count = 0
> 3. A는 조회한 프로토타입 빈에 addCount()를 호출 -> count = count+1 (1);
>
> 
>
> 4. B가 스프링 컨테이너에 프로토타입 빈을 요청
> 5. 컨테이너는 프로토타입 빈을 새로 생성해서 반환 (x02), count = 0
> 6. B는 조회한 프로토타입 빈에 addCount()를 호출 -> count = count+1  (1);

= 둘다 정상적으로 count가 1이 됨



<싱글톤 빈이 의존관계 주입을 통해 프로토타입 빈을 주입받아서 사용하는 경우>

> 1. 싱글톤 빈(SB)는 스프링 컨테이너 생성 시점에 생성, 의존관계 주입
> 2. 의존관계 자동 주입 사용 -> 주입 시점에 프로토타입 빈을 컨테이너에 요청
> 3. 컨테이너는 프로토타입 빈을 생성해서 A에게 반환 (count = 0)
> 4. SB는 프로토타입 빈을 내부 필드에 보관 (참조값)
>
> 
>
> 5. 클라이언트 A가 SB를 스프링 컨테이너에 요청 -> 싱글톤이니깐 같은 SB가 반환
> 6. A는 SB의 로직을 호출 -> SB는 addCount()를 호출해서 프로토타입 빈의 count를 증가 (count = 1)
>
> 
>
> 7. 클라이언트 B가 SB를 스프링 컨테이너에 요청 -> 싱글톤이니깐 같은 SB가 반환
>
> 8. 근데 SB가 내부에 가지고 있던 프로토타입 빈은 이미 과거에 주입이 끝난 빈 
>
>    (프로토타입 빈은 주입 시점에 새로 생성되지, 사용 될때마다 생성되는 게 아님)
>
> 9. B는 SB의 로직을 호출 -> SB가 addCount()호출해서 프로토타입 빈의 count를 증가 (count = 2)

= 하나의 프로토타입 빈에 count가 2가 되어버림.



왜냐면 싱글톤 빈이 프로토타입 빈을 사용 -> 싱글톤 빈은 생성 시점에 의존관계 주입 -> 프로토타입 빈이 생성되어도 이 싱글톤 빈과 끝까지 함께 가게 됨.



근데 우리의 의도는 logic을 호출할 때마다(사용할때마다) 새로 프로토타입 빈을 만들고 싶음.



#### 프로토타입 스코프 - Provider로 문제 해결

로직 호출할때마다 컨테이너에 요청해서 프로토타입 빈을 새로 주입받아서 하기 -> 너무너무 지저분함.

DI가 아니라 직접 필요한 의존관계를 찾기 (DL) 

근데 어플리케이션 컨텍스트 전체를 주입받으면 스프링 컨테이너에 너무 종속적인 코드, 어려운 테스트



[방법 1]

ObjectProvider<?>에서 getObject()를 호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환 (DL)

-> 컨테이너에서 얘가 대신 잘 찾아주는 역할.

-> 프로토타입의 경우, 새로 생성되는 효과가 발생.

ObjectFactory는 부모 클래스 (기능 단순)

심지어 스프링이 자동으로 만들어서 주입해줌.



[방법2]

javax.inject.Provider를 사용하는 방법 (gradle에 javax.inject:javax.inject:1 라이브러리 추가하기)

Provider<?> 의 get()을 사용하기

진짜 딱 필요한 DL 정도의 기능만 사용, 스프링 아니어도 가능

근데 라이브러리를 추가해야 함.



프로토타입 빈은 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하기.

근데 보통 싱글톤 빈이면 대부분의 문제를 해결함.