## 프록시

* em.find() : 실제 엔티티 객체 조회
* em.getReference() : DB 조회를 미루는 가짜 엔티티 조회



#### 프록시

가짜 엔티티 (프록시) -> 껍데기는 같은데 안이 비어있음. (Hibernate가 실제 클래스를 상속 받아서 만듦)

프록시 객체는 실제 객체(타겟)의 참조를 보관

사용하는 입장에서는 진짜 객체인지 , 프록시 객체인지 구분하지 않고 사용

1. 사용자가 요청
2. 프록시가 영속성 컨텍스트에 초기화 요청
3. 영속성 컨텍스트에서 DB 조회
4. DB에서 데이터를 꺼내 와 실제 엔티티 생성
5. 프록시에서 실제 객체에 요청
6. 사용자에게 줌



**중요**

프록시 객체는 처음 사용할 때 한번만 초기화 (1번 초기화 되면 그걸로 계속 씀)

초기화 시 실제 엔티티로 바뀌는 건 아님, 그냥 접근이 가능해지는 것

프록시 객체는 원본 엔티티를 상속 -> 타입 체크시 == 불가능 / instance of 사용



이미 영속성 컨텍스트에 찾는 엔티티가 있으면 em.getReference라도 실제 엔티티 반환

이유) **JPA 기본 원칙** : 한 트랜잭션 안에서 pk가 같으면 JPA는 항상 같은 값을 반환해야함.

> -> 프록시로 이후에 가져오더라도 이 원칙을 유지하기 위해 그냥 실제 엔티티를 줌



a : 프록시 조회, b : 실제 조회-> A와 B 비교하면 둘다 프록시로 뜸

왜냐면 역시 JPA는 같은 값을 반환하려는 원칙을 지키기 위해서

핵심은 프록시든 실제 객체든 상관없게 코딩을 합시다.



영속성 컨텍스트의 도움을 받을 수 없을때 (em.detach()로 준영속 or em.close로 끄기)

-> 에러 발생

이유) 프록시 객체는 영속성 컨텍스트로부터 초기화받음 -> 영속성 컨텍스트가 있어야지만 사용 가능

> 보통 트랜잭션 시작-끝에 영속성 컨텍스트 끝 맞춤.
>
> 트랜잭션 끝나고 프록시 객체 조회시 주로 에러 많이 뜸



#### 프록시 확인

초기화 여부 확인 : EntityManagerFactory.PersistenceUnit.isLoaded(Object entity)

프록시 클래스 확인은 그냥 무식하게 찍기 getClass()

강제 초기화는 Hibernate.initialize(entity)

> JPA 표준에서는 강제 초기화 없음



#### 문제

Member 테이블과 Team이 연관인 상태에서 어쩔때는 멤버만 가져오고, 어쩔때는 둘다 가져오고 싶을 때가 있다.

-> 멤버만 가져오고 싶음 : 지연 로딩 (LAZY) 사용

@ManyToOne(fetch = FetchType.LAZY) 설정



이러면 연관된 속성을 사용하는 시점에, 프록시 객체가 초기화되면서 가져옴



#### 지연 로딩

지연 로딩을 사용하면, Member-Team이 연관되어있는 상태에서 Team에는 가짜 프록시 객체를 세팅

Team에 내용을 실제 사용하는 시점에 DB조회해서 가져옴

<-> 반면 즉시 로딩은 한방에 땡겨옴

실무에서 가급적 지연 로딩만 사용하는게 좋음



#### 즉시 로딩의 단점

1) 전혀 예상하지 못한 SQL 발생

> Member를 가져왔는데 막 join이 지 맘대로 이루어짐

2)  JPQL에서 N+1 문제를 일으킴

> jpql은 그대로 sql문으로 바꿔서 실행
>
> -> member를 일단 다 가져옴 (1) -> 근데 즉시로딩이네?
>
> -> 그럼 member 수만큼 team을 가져올라고 쿼리가 다시나감 (N) -> N+1문제



JPQL에서 LAZY일때 한번에 값을 어떻게 가져오냐 -> fetch join 사용



@ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정

@ManyToMany, @OneToMany는 기본이 지연 로딩



**<상황>**

A, B 자주사용 -> 즉시 로딩 

A, C 가끔사용 -> 지연 로딩

B,C 자주사용 -> 즉시 로딩

A조회시 A-B는 즉시로딩이라 한방 쿼리 / C는 프록시로

C 터치시 B-C가 즉시로딩이라 한방 쿼리가 나감



> 여하간 무조건 지연로딩 쓰세요



#### 영속성 전이

CASCADE는 그냥 부모 저장할 때 연관된 자식도 저장하고 싶을때

> persist 할때 부모만 해도 자식들도 다 입력되게 하고 싶을 때



(보통 이렇게 많이 씀)

* ALL : 모두
* PERSIST : 영속
* REMOVE : 삭제



쓰면 안될 떄 : 자식을 부모A 말고도 다른 부모들도 관리할 때 (소유자 1개일 때)



#### 고아 객체

부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제

* orphanRemoval = true 옵션

CASCADE REMOVE처럼 동작

역시 특정 엔티티가 개인 소유일 때만 사용 (다른사람이 안건들때)



#### CASCADE + 고아 객체

스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거

두 옵션을 활성화하면 부모 객체를 컨트롤 -> 자식도 동일하게 사용가능

* 도메인 주도 설계에서 Aggregate Root에서 유용 (Repository는 root만 컨텍하게)