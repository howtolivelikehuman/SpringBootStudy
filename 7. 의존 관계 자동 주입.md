## 7. 의존 관계 자동 주입

#### 의존 관계 주입 방법

* 생성자 주입

  > 생성자 호출 시점에 딱 1번만 호출
  >
  > **불변**, **필수** 의존관계에 사용
  >
  > private final을 통해 언어적으로 생성자에 null 방지 가능
  >
  > 생성자 1개면 @Autowired 생략해도 자동으로 됨 (스프링 빈)

  빈을 등록해야됨 -> 객체를 만들어야함 -> 생성자가 호출됨 -> 주입까지 되어버림.

* 수정자 주입 (setter)

  > 필드 값을 수정시 setter를 사용하는 관례 사용 (자바빈 프로퍼티 규약)
  >
  > **선택**, **변경** 가능성이 있는 의존관계에 사용
  >
  > -> 선택적으로 하려면 (required = false) 추가
  >
  > setter에 @Autowired 넣기

* 필드 주입

  > 필드에 바로 주입하는 방법
  >
  > 외부에서 변경 불가능 -> 테스트 하기 힘듦.
  >
  > DI 프레임워크가 없으면 아무것도 할 수 없음.
  >
  > 실제 코드랑 관계 없는 테스트 코드 스프링 설정용 @Configuration 같은 곳에서만 특별하게 사용

* 일반 메서드 주입

  > 아무 메서드를 통해 주입.
  >
  > 한번에 여러 필드를 주입 받을 수 있음 (근데 일반적으로 잘 안씀)
  >
  > 스프링 컨테이너가 관리하는 스프링 빈이어야지만 동작



주입할 스프링 빈이 없어도 동작해야 할 때가 있음 

@Autowired(required = true) 면 자동 주입 대상 없어서 오류



@Autowired(required = false)-> 의존관계 없을 때 메소드 자체가 아예 안됨

@Nullable -> 없으면 null 입력

Optional< > -> 없으면 Optional.empty



#### 생성자 주입 권장

요새는 생성자 주입 권장.



1. 불변

   보통 DI는 한번 일어나면 끝날때까지 일어나면 안됨 (대부분은 오히려 변경하면 안됨)

   수정자 주입 할꺼면 set을 public으로 열어버려야 함 -> 누군가의 실수로 변경 가능

   

2. 누락

   순수한 자바 코드에 대해 테스트코드를 짜고 싶을때 수정자로 할 경우 > 

   수정자 주입을 사용할 때 -> 필드에 대해 nullpointexception 발생가능성

   테스트 짜는 입장에서는 의존관계가 눈에 들어오지 않기 때문.

   하지만 생성자 주입시 컴파일 오류로 알아낼 수 있음

   

3. Final 키워드 사용 가능

   생성자에서만 값을 세팅할 수 있음 -> 바꾸려 하면 컴파일 오류 발생

   그리고 누락시에 컴파일 오류 발생해줌

   나머지 주입 방식은 생성자 이후 호출 -> final 못씀



디폴트로 생성자 쓰다가, 필수가 아닌 경우 (옵션) 이때 수정자 주입 하기

필드 주입은 쓰지 말기!



**컴파일 오류가 세상에서 제일 좋은 오류**



#### 롬복, 최신 트렌드

막상 개발 해보면 99% 불변 -> final을 사용하게 됨

근데 생성자 만들기, 값 대입 코드 (this.....) 이거 하기 너무너무 귀찮음



@RequiredArgsConstructor

-> final 붙은 필드를 모두 파라미터로 하는 생성자를 자동으로 만들어줌

깔끔하게 코드 가능



#### 빈이 두개 이상 중복되는 경우



1. @Autowired에 필드명 매칭

   여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭

   파라미터 이름을 맞춰주기

   

2. @Qualifier 끼리 매칭 (빈 이름)

   @Qualifier로 매칭하기 -> 만약 매칭할 거를 못찾으면 어떻게 될까?

   그럼 이 이름의 스프링 빈을 추가로 찾으려고 노력 -> 이래도 없으면 예외

   빈 직접 등록시에도 동일하게 사용 가능

   * 모든 코드에 Qualifier 붙여야 함 (귀찮음)

   * 엄청 헷갈리니깐 Qualifier 쓰는 애들끼리만 명확하게 쓰기

   

3. @Primary 사용

   * 제일 자주 씀 -> @Primary가 제일 먼저 되게

   ex) 메인DB (90% 사용) - 보조DB (10%) -> 이때 메인DB 쓰는 코드에 @Primary로 쓰자

   보조DB 쓰고 싶을때는 Qualifier 쓰자

   둘이 겹쳤을 때 우선순위는 Qualifier가 더 높음. (Primary는 디폴트처럼 동작)



#### Annotation 만들기

@Qualifier("abc") ->이러면 문자열이라 타입 체크가 힘듦

@Annotation 만들어서 거기에 어노테이션들 합체하고 그거 쓰기.



#### 조회한 빈이 모두 필요할때 List, Map

Map을 이용해서 이름을 key 값으로 원하는 정책을 선택할 수 있게 해줌.



#### 자동, 수동 실무 운영 기준

점점 자동을 선호하는 추세, Spring Boot는 컴포넌트 스캔이 기본

설정 정보로 수동으로 빈을 등록하면 너무 귀찮음 -> @Component만 하면 되는데, 굳이 @Bean 적고 하는게 힘듦

자동 빈 등록을 해도 OCP, DIP 지킬 수 있음



수동 빈 등록을 사용할 때

1. 기술 로직

   APP는 두가지 로직

   > 업무 로직 빈 : 컨트롤러, 핵심 비즈니스 서비스, 데이터계층 로직 처리 (리포지토리) 등
   >
   > -> 비즈니스 요구사항 개발할 때
   >
   > 기술 지원 빈 : 기술적인 문제나 공통 관심사 처리용, DB 연결, 로그처리 업무 등의 공통 기술

   여기서 업무 로직은 숫자가 많음

   EX) 컨트롤러 - 서비스 - 리포지토리의 유사한 패턴 -> 자동 기능 적극 활용

   문제가 발생해도 어디서 생겼는지 명확하게 파악하기 쉬움

   반면 기술 로직은 업무 로직과 비슷해 수가 매우 적음. 어플리케이션 전반에 걸쳐서 광범위하게 영향.

   잘 되고 있는지 파악하기 어려운 경우가 많음 -> 수동으로 명확하게 드러내기

   

2. 다형성 적극 활용

   Map을 사용하여 다형성 활용, 자동으로 주입받는 경우 -> 어떤 빈들이 주입되는지 한눈에 보기 힘듦

   만약 자동 등록을 사용하고 싶으면, 같은 **패키지**에 모아 놔서 파악하기.

   

스프링과 스프링 부트가 자동으로 등록하는 빈들은 예외 -> 어련히 다 이유가 있다.

ex)  DataSource 같은 DB 연결 기술 지원 로직은 스프링 부트에서 자동으로 등록 해줌.