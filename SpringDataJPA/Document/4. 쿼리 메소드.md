#### 쿼리 메소드

JpaRepository 인터페이스에 문법대로 메소드를 생성해주면, 구현하지 않아도 잘 작동한다.

필터링 조건은 SpringData 공식 문서에 있음

`Distinct`, `And`, `Or`, `Between`,`StartingWith` 이런것 등등 있음.



하지만 이걸로도 안될 때가 있음 + 조건을 더 추가하려면 메소드명이 너무 길어짐

-> 2개 정도 까지는 JPA, 이후에는 JPQL 직접 짜기도 가능



find...By + And/Or + xxxBy...

read...By, queyr...By, get....By 등등 존재

* count...By : long으로 개수 받음
* exists...By : boolean으로 있는지 확인
* delete, remove로 삭제도 가능
* findFirst3 등등으로 위에 3개 만 LIMIT해서 가져올 수 있음.



단순노동에서 주로 사용

**Spring이 아닌 엔티티쪽이 변경되면 -> 실행 시점에서 에러로 걸림**



#### NamedQuery

엔티티에 NamedQuery 설정

````java
@NamedQuery(
        name = "Member.findByUsername",
        query = "select m from Member m where m.username = :username"
)
````

쿼리문의 이름을 불러서 사용 가능

````java
 public List<Member> findByUsername(String username){
        return em.createNamedQuery("Member.findByUsername", Member.class)
        .setParameter("username",username)
        .getResultList();
    }
````



이것 역시 편리하게 DataJPA로 가능

````java
@Query(name = "Member.findByUsername")
List<Member> findByUsername(@Param("username") String username);
````

이때 @Param은 JPQL에서 `:username`과 같이 명확하게 파라미터를 넘겨야 할 때

이때 @Query 생략해도 작동하긴 함



왜냐면 DataJPA가 검색하는 관례 때문.

DataJpa가 메소드를 실행할 때 맨 처음 엔티티타입.xxx로 메소드들을 탐색함

-> 여기서 NamedQuery가 먼저 검색되는 것.

-> 없으면 이제 규칙에 따라 메소드 이름으로 쿼리 생성



> 사실 NamedQuery를 잘 사용하지는 않음
>
> 메소드에 그냥 바로 쿼리를 지정하는게 훨씬 쓸모있음

기존 createQuery에서 JPQL 작성 시 어차피 String 타입이라 오타가 발생해도 실무에서 실행해봐야 알음

하지만 NamedQuery 실행 시점에서 오타를 잡아낼 수 있음 (정적 쿼리라서 로딩시점에 다 파싱)



#### @Query로 리포지토리에 바로 작성

````java
@Query("select m from Member m where m.username = :username and m.age = : age")
List<Member> findUser(@Param("username") String username, @Param("age") int age);
````

복잡한 JPQL을 메소드에 바로바로 붙여줌. 메소드명도 마음대로 가능

이방법 역시 오타가 발생하면 로딩 시점에서 바로 잡아줌.



동적쿼리는 QueryDsl 쓰기!



#### 값, DTO 조회

````java
@Query("select m.username from Member m")
List<String> findUsernameList();
````

이런 식으로 값만 조회 가능



````java
@Query("select new study.datajpa.dto.MemberDto (m.id, m.username, t.name) from Member m join m.team t")
List<MemberDto> findMemberDto();
````

이렇게 DTO도 가능. 

Query는 JPQL에서 DTO를 select하는 문법과 동일하게 사용



#### 파라미터 바인딩

* 이름 기반 : `:name` 이름
* 위치 기반 : `1?` 순서

근데 무조건 이름 기반 쓰기 (코드 가독성, 유지보수성)



컬렉션에 대해서도 파라미터 바인딩 가능 (IN으로 여러개 조회)

````java
@Query("select m from Member m where m.username in :names")
List<Member> findByNames(@Param("names") List<String> names);
````

