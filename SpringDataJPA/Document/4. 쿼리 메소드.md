#### 쿼리 메소드

JpaRepository 인터페이스에 문법대로 메소드를 생성해주면, 구현하지 않아도 잘 작동한다.

필터링 조건은 SpringData 공식 문서에 있음

`Distinct`, `And`, `Or`, `Between`,`StartingWith` 이런것 등등 있음.



하지만 이걸로도 안될 때가 있음 + 조건을 더 추가하려면 메소드명이 너무 길어짐

-> 2개 정도 까지는 JPA, 이후에는 JPQL 직접 짜기도 가능



find...By + And/Or + xxxBy...

read...By, queyr...By, get....By 등등 존재

* count...By : long으로 개수 받음
* exists...By : boolean으로 있는지 확인
* delete, remove로 삭제도 가능
* findFirst3 등등으로 위에 3개 만 LIMIT해서 가져올 수 있음.



단순노동에서 주로 사용

**Spring이 아닌 엔티티쪽이 변경되면 -> 실행 시점에서 에러로 걸림**



#### NamedQuery

엔티티에 NamedQuery 설정

````java
@NamedQuery(
        name = "Member.findByUsername",
        query = "select m from Member m where m.username = :username"
)
````

쿼리문의 이름을 불러서 사용 가능

````java
 public List<Member> findByUsername(String username){
        return em.createNamedQuery("Member.findByUsername", Member.class)
        .setParameter("username",username)
        .getResultList();
    }
````



이것 역시 편리하게 DataJPA로 가능

````java
@Query(name = "Member.findByUsername")
List<Member> findByUsername(@Param("username") String username);
````

이때 @Param은 JPQL에서 `:username`과 같이 명확하게 파라미터를 넘겨야 할 때

이때 @Query 생략해도 작동하긴 함



왜냐면 DataJPA가 검색하는 관례 때문.

DataJpa가 메소드를 실행할 때 맨 처음 엔티티타입.xxx로 메소드들을 탐색함

-> 여기서 NamedQuery가 먼저 검색되는 것.

-> 없으면 이제 규칙에 따라 메소드 이름으로 쿼리 생성



> 사실 NamedQuery를 잘 사용하지는 않음
>
> 메소드에 그냥 바로 쿼리를 지정하는게 훨씬 쓸모있음

기존 createQuery에서 JPQL 작성 시 어차피 String 타입이라 오타가 발생해도 실무에서 실행해봐야 알음

하지만 NamedQuery 실행 시점에서 오타를 잡아낼 수 있음 (정적 쿼리라서 로딩시점에 다 파싱)



#### @Query로 리포지토리에 바로 작성

````java
@Query("select m from Member m where m.username = :username and m.age = : age")
List<Member> findUser(@Param("username") String username, @Param("age") int age);
````

복잡한 JPQL을 메소드에 바로바로 붙여줌. 메소드명도 마음대로 가능

이방법 역시 오타가 발생하면 로딩 시점에서 바로 잡아줌.



동적쿼리는 QueryDsl 쓰기!



#### 값, DTO 조회

````java
@Query("select m.username from Member m")
List<String> findUsernameList();
````

이런 식으로 값만 조회 가능



````java
@Query("select new study.datajpa.dto.MemberDto (m.id, m.username, t.name) from Member m join m.team t")
List<MemberDto> findMemberDto();
````

이렇게 DTO도 가능. 

Query는 JPQL에서 DTO를 select하는 문법과 동일하게 사용



#### 파라미터 바인딩

* 이름 기반 : `:name` 이름
* 위치 기반 : `1?` 순서

근데 무조건 이름 기반 쓰기 (코드 가독성, 유지보수성)



컬렉션에 대해서도 파라미터 바인딩 가능 (IN으로 여러개 조회)

<<<<<<< HEAD
````java
@Query("select m from Member m where m.username in :names")
List<Member> findByNames(@Param("names") List<String> names);
````

=======
#### 반환 타입

````java
//컬렉션
List<Member> findListByUsername(String username);
//단건
Member findMemberByUsername(String username);
//Optional로 한개
Optional<Member> findOptionalByUsername(String username);
````

이런 식으로 반환 타입을 자유롭게 사용 가능.

`T`, `WrapperType`,`Stream` 등등 다양한 타입 가능



이때 Collection으로 Return받는 경우, 값이 없으면 null이 아니라 빈 컬렉션을 반환함

그래서 `result != null`하면 대참사

근데 단건 조회시에는 null임



JPA에서는 결과 없으면 noResultException이 뜨지만, DataJPA에서는 자체적으로 try-catch로 Exception처리를 해줘서 null/empty를 뱉어줌



하지만 JAVA8이후 Optional의 등장으로 데이터 있을지 없을지 모르면 알아서 자기가 처리할 수 있게 됨



**Optional에서 단건이 아니라 여러개가 조회되면 예외 발생**

NonUniqueException을 (DataJPA) -> Spring에서의 IncorrectResultSizeDataAccessException으로 변환해줌

Repository의 기술이 JPA 말고 다른 기술일 수 있기 때문에, Spring 단에서 동일하게 처리하기 위해 더 상위단계로 변환시켜주는거.



#### JPA 페이징, 정렬

JPA에서는 JPQL을 통해 페이징 할 수 있음

````java
public List<Member> findByPage(int age, int offset, int limit){
    return em.createQuery("select m from Member m where " +
                          "m.age = :age order by m.username desc")
        .setParameter("age", age)
        .setFirstResult(offset)
        .setMaxResults(limit)
        .getResultList();
}
````

JPQL이 자동으로 해당 DBMS에 맞게 쿼리문을 짜서 작동함



이때 또 귀찮은건 페이지 계산 공식

totalPage   = totalCount / size ...

마지막 페이지인지, 최초 페이지인지 생각하는게 힘듦



#### Data JPA의 페이징

`org.springframework.data.domain.Sort` : 정렬

`org.springframework.date.domain.Pageable` : 페이징 기능 (내부 sort 포함)

이 두 인터페이스로, DBMS에 종속되지 않고 가능



`org.springframework.data.domain.Page` : 전체 페이지 있는 페이지

`org.springframework.data.domain.Slice` : 더보기 등의 특별한 타입도 가능 (전체 페이지 없이)

->limit +1을 가져와서 다음페이지가 있는지 없는지 확인 가능



````java
Page<Member> findByAge(int age, Pageable pageable);

-> 
    PageRequest pageRequest = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "username"));
    Page<Member> pages = memberRepository.findByAge(age, pageRequest);
````

이런 식으로 사용 가능. 페이지는 0부터

알아서 Page형태로 뱉어내기 위해서 Data Jpa가 알아서 totalPage까지 계산해서 넘겨줌

당연하게도 Slice에서는 totalCount쿼리가 없어서 totalElements, totalPages 모름 



사실 페이징 자체는 개수를 딱 정해서 가져오는데, Option + Join에서 가져오는 totalCount에서 성능이슈가 많이 발생

where문 같은 Option이 없으면, CountQuery에서 까지 딱히 join을 굳이 할 필요가 없는 경우도 있음

그래서 CountQuery를 분리하는 것도 가능.

````java
@Query(value = "select m from Member m left join m.team t",
       countQuery = "select count(m.username) from Member m")
Page<Member> findByAge(int age, Pageable pageable);
````

Sorting도 복잡한 상황에서는 따로 쿼리문 분리 가능.



**이때 이 Page를 절대 API 밖으로 내보내면 안됨!!!!!!!!**

엔티티를 밖으로 내보내면 절대 안됨. (엔티티 변경시 스펙 변경 -> 프론트에서 망치들고 찾아옴)

따라서 DTO로 무조건 mapping해야됨.

````java
//이걸로 반환해서 뱉기
Page<MemberDto> pageMap = pages.map(member -> new MemberDto(member.getId(), member.getUsername(), null));
````



#### 벌크성 수정 쿼리

JPA는 더티체킹을 통해 commit 시점에 바뀌면 쿼리를 날림 (단건)

벌크성 쿼리는 한번에 여러개를 update / insert 하는 경우

````java
@Modifying
@Query("update Member m set m.age = m.age+1 where m.age >= :age")
int bulkAgePlus(@Param("age") int age);
````

이때 중요한 부분은 @Modifying 이 있어야 excuteUpdate를 함

저거 없으면 select로 날릴려고 해서 에러



이때 JPA에서는 영속성 컨텍스트로 엔티티들을 관리함.

하지만 bulk연산은 그걸 다 무시하고 DB에 쿼리를 날려버리는 것 (영속성 컨텍스트와 충돌 가능)



**문제**

````java
memberRepository.save(new Member("mem5", 40));
int resultCount = memberRepository.bulkAgePlus(20);
List<Member> result = memberRepository.findByUsername("mem5");
Member member5 = result.get(0);
````

> 위의 bulk메소드를 사용한 mem5의 경우
>
> DB에는 벌크연산이 실행되어 41살이지만,  JPA의 영속성 컨텍스트에선 40살이 되어버림
>
> 그래서 mem5를 조회해보면 40살이라 뜸
>
> -> 벌크 연산이후에는 영속성 컨텍스트를 초기화해야 함!!!!!

````java
//같은 트랜잭션에선 같은 엔티티매니저
@PersistenceContext EntityManager em;
//...
em.flush();
em.clear(); //<- 초기화
````

아니면 `@Modifying(clearAutomatically = true)` 옵션을 통해서도 가능.



**Spring JPA 와 bulk연산, mybatis 등을 혼용하여 사용할 때 쿼리 날리면 항상 영속성 컨텍스트를고려해줘야 함.**



#### 엔티티그래프

보통 다대일관계 -> LazyLoading (프록시 객체를 가져왔다가, 사용하는 시점에 가져옴)

사용하는 시점에 가져오는 경우 -> N+1 문제 발생 (쿼리 증폭됨)

이걸 해결하는게 **Fetch Join** 엔티티 그래프에서 연관이 있는 엔티티들을 다 가져옴. 쿼리하나로 끝내기

````java
@Query("select m from Member m left join fetch m.team")
````

fetch를 넣어주면, 기존 애 조회시 연관된 애들을 다 조회해줌 



근데 Spring Data JPA에서 무조건 JPQL 쓰기는 귀찮음 -> @EntityGraph를 사용하기

````java
@Override //findAll을 재정의하고 싶으면 Override
@EntityGraph(attributePaths = {"team"}) 
List<Member> findAll();
````

이러면 Data JPA에서 내부적으로 Fetch Join을 사용해줌.

```java
@EntityGraph(attributePaths = {"team"})
@Query("select m from Member m")
List<Member> findmemberEntityGraph();
```

이런식으로 JPQL과 혼용해서도 사용 가능.

````java
@NamedEntityGraph(name="Member.all" ,
        attributeNodes = @NamedAttributeNode("team"))
//...
@EntityGraph("Member.all")
List<Member> findMemberEntityGraph();
````

역시 @NamedEntityGraph를 통해서 이름 설정 가능



근데 쿼리가 복잡해지면 결국 findBy 등의 메소드로는 불가 -> 어차피 쿼리를 짜야 함 -> JPQL 사용

간단간단한거는 굳이 JPQL 말고 이거 사용
