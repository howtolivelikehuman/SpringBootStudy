#### 반환 타입

````java
//컬렉션
List<Member> findListByUsername(String username);
//단건
Member findMemberByUsername(String username);
//Optional로 한개
Optional<Member> findOptionalByUsername(String username);
````

이런 식으로 반환 타입을 자유롭게 사용 가능.

`T`, `WrapperType`,`Stream` 등등 다양한 타입 가능



이때 Collection으로 Return받는 경우, 값이 없으면 null이 아니라 빈 컬렉션을 반환함

그래서 `result != null`하면 대참사

근데 단건 조회시에는 null임



JPA에서는 결과 없으면 noResultException이 뜨지만, DataJPA에서는 자체적으로 try-catch로 Exception처리를 해줘서 null/empty를 뱉어줌



하지만 JAVA8이후 Optional의 등장으로 데이터 있을지 없을지 모르면 알아서 자기가 처리할 수 있게 됨



**Optional에서 단건이 아니라 여러개가 조회되면 예외 발생**

NonUniqueException을 (DataJPA) -> Spring에서의 IncorrectResultSizeDataAccessException으로 변환해줌

Repository의 기술이 JPA 말고 다른 기술일 수 있기 때문에, Spring 단에서 동일하게 처리하기 위해 더 상위단계로 변환시켜주는거.



#### JPA 페이징, 정렬

JPA에서는 JPQL을 통해 페이징 할 수 있음

````java
public List<Member> findByPage(int age, int offset, int limit){
    return em.createQuery("select m from Member m where " +
                          "m.age = :age order by m.username desc")
        .setParameter("age", age)
        .setFirstResult(offset)
        .setMaxResults(limit)
        .getResultList();
}
````

JPQL이 자동으로 해당 DBMS에 맞게 쿼리문을 짜서 작동함



이때 또 귀찮은건 페이지 계산 공식

totalPage   = totalCount / size ...

마지막 페이지인지, 최초 페이지인지 생각하는게 힘듦



#### Data JPA의 페이징

`org.springframework.data.domain.Sort` : 정렬

`org.springframework.date.domain.Pageable` : 페이징 기능 (내부 sort 포함)

이 두 인터페이스로, DBMS에 종속되지 않고 가능



`org.springframework.data.domain.Page` : 전체 페이지 있는 페이지

`org.springframework.data.domain.Slice` : 더보기 등의 특별한 타입도 가능 (전체 페이지 없이)



````java
Page<Member> findByAge(int age, Pageable pageable);

-> 
    PageRequest pageRequest = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "username"));
    Page<Member> pages = memberRepository.findByAge(age, pageRequest);
````

이런 식으로 사용 가능.

알아서 Page형태로 뱉어내기 위해서 Data Jpa가 알아서 totalPage까지 계산해서 넘겨줌

당연하게도 Slice에서는 totalCount쿼리가 없어서 totalElements, totalPages 모름



사실 페이징 자체는 개수를 딱 정해서 가져오는데, Option + Join에서 가져오는 totalCount에서 성능이슈가 많이 발생

where문 같은 Option이 없으면, CountQuery에서 까지 딱히 join을 굳이 할 필요가 없는 경우도 있음

그래서 CountQuery를 분리하는 것도 가능.

````java
@Query(value = "select m from Member m left join m.team t",
       countQuery = "select count(m.username) from Member m")
Page<Member> findByAge(int age, Pageable pageable);
````

Sorting도 복잡한 상황에서는 따로 쿼리문 분리 가능.



**이때 이 Page를 절대 API 밖으로 내보내면 안됨!!!!!!!!**

엔티티를 밖으로 내보내면 절대 안됨. (엔티티 변경시 스펙 변경 -> 프론트에서 망치들고 찾아옴)

따라서 DTO로 무조건 mapping해야됨.

````java
//이걸로 반환해서 뱉기
Page<MemberDto> pageMap = pages.map(member -> new MemberDto(member.getId(), member.getUsername(), null));
````

