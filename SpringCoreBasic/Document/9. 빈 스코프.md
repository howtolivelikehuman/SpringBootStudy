## 9. 빈 스코프

스프링 컨테이너의 시작과 함께 생성 - 종료될때 유지 -> 싱글톤 스코프



* 싱글톤 : 기본, 컨테이너 시작과 종료까지 유지 (가장 넓음)
* 프로토 타입 : 컨테이너는 프로토타입 빈 생성, 의존관계 주입까지만 관여 -> 그뒤에는 관리 X
* 웹 관련
  * request 
  * session
  * application



#### 프로토타입 스코프

프로토타입 스코프는 스프링 컨테이너가 항상 새로운 인스턴스 생성-반환



[싱글톤 빈 요청]

1. 싱글톤 스코프 빈 스프링 컨테이너에 요청
2. 스프링 컨테이너는 자기가 관리하는 스프링 빈 반환
3. 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈 반환



[프로토타입 빈 요청]

1. 프로토타입 스코프 빈 컨테이너에 요청
2. 컨테이너가 프로토타입 빈 생성, 의존관계 주입
3. 생성한거 클라이언트에 반환
4. 같은 요청이 오면 위 과정을 반복



컨테이너는 프로토타입 빈 생성, 의존관계 주입, 초기화 까지만 딱 관여-> @PreDestroy같은 종료 메소드 호출 X



#### 프로토타입 스코프 - 싱글톤 빈과 같이 쓰면 문제점

<스프링 컨테이너에 프로토타입 빈을 직접 요청하는 경우>

> 1. A가 스프링 컨테이너에 프로토타입 빈을 요청
> 2. 컨테이너는 프로토타입 빈을 새로 생성해서 반환 (x01), count = 0
> 3. A는 조회한 프로토타입 빈에 addCount()를 호출 -> count = count+1 (1);
>
> 
>
> 4. B가 스프링 컨테이너에 프로토타입 빈을 요청
> 5. 컨테이너는 프로토타입 빈을 새로 생성해서 반환 (x02), count = 0
> 6. B는 조회한 프로토타입 빈에 addCount()를 호출 -> count = count+1  (1);

= 둘다 정상적으로 count가 1이 됨



<싱글톤 빈이 의존관계 주입을 통해 프로토타입 빈을 주입받아서 사용하는 경우>

> 1. 싱글톤 빈(SB)는 스프링 컨테이너 생성 시점에 생성, 의존관계 주입
> 2. 의존관계 자동 주입 사용 -> 주입 시점에 프로토타입 빈을 컨테이너에 요청
> 3. 컨테이너는 프로토타입 빈을 생성해서 A에게 반환 (count = 0)
> 4. SB는 프로토타입 빈을 내부 필드에 보관 (참조값)
>
> 
>
> 5. 클라이언트 A가 SB를 스프링 컨테이너에 요청 -> 싱글톤이니깐 같은 SB가 반환
> 6. A는 SB의 로직을 호출 -> SB는 addCount()를 호출해서 프로토타입 빈의 count를 증가 (count = 1)
>
> 
>
> 7. 클라이언트 B가 SB를 스프링 컨테이너에 요청 -> 싱글톤이니깐 같은 SB가 반환
>
> 8. 근데 SB가 내부에 가지고 있던 프로토타입 빈은 이미 과거에 주입이 끝난 빈 
>
>    (프로토타입 빈은 주입 시점에 새로 생성되지, 사용 될때마다 생성되는 게 아님)
>
> 9. B는 SB의 로직을 호출 -> SB가 addCount()호출해서 프로토타입 빈의 count를 증가 (count = 2)

= 하나의 프로토타입 빈에 count가 2가 되어버림.



왜냐면 싱글톤 빈이 프로토타입 빈을 사용 -> 싱글톤 빈은 생성 시점에 의존관계 주입 -> 프로토타입 빈이 생성되어도 이 싱글톤 빈과 끝까지 함께 가게 됨.



근데 우리의 의도는 logic을 호출할 때마다(사용할때마다) 새로 프로토타입 빈을 만들고 싶음.



#### 프로토타입 스코프 - Provider로 문제 해결

로직 호출할때마다 컨테이너에 요청해서 프로토타입 빈을 새로 주입받아서 하기 -> 너무너무 지저분함.

DI가 아니라 직접 필요한 의존관계를 찾기 (DL) 

근데 어플리케이션 컨텍스트 전체를 주입받으면 스프링 컨테이너에 너무 종속적인 코드, 어려운 테스트



[방법 1]

ObjectProvider<?>에서 getObject()를 호출하면 내부에서 스프링 컨테이너를 통해 해당 빈을 찾아서 반환 (DL)

-> 컨테이너에서 얘가 대신 잘 찾아주는 역할.

-> 프로토타입의 경우, 새로 생성되는 효과가 발생.

ObjectFactory는 부모 클래스 (기능 단순)

심지어 스프링이 자동으로 만들어서 주입해줌.



[방법2]

javax.inject.Provider를 사용하는 방법 (gradle에 javax.inject:javax.inject:1 라이브러리 추가하기)

Provider<?> 의 get()을 사용하기

진짜 딱 필요한 DL 정도의 기능만 사용, 스프링 아니어도 가능

근데 라이브러리를 추가해야 함.



프로토타입 빈은 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하기.

근데 보통 싱글톤 빈이면 대부분의 문제를 해결함.



#### 웹 스코프

* request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의  HTTP 요청마다 별도의 빈 인스턴스 생성, 관리
* session : HTTP Session과 동일한 생명주기
* application : ServletContext와 동일한 생명주기
* websocket : 웹 소켓과 동일한 생명주기



[Request 동작 과정]

1. Client A가 HTTP request 요청
2. 컨트롤러에서 Request scope 관련 객체 조회
3. Client A 전용 객체 생성
4. Service에서 조회 시 HTTP request가 같으면 같은 객체 바라봄
5. Client B가 HTTP request 요청
6. 다른 요청이므로 별도의 객체 생성



#### 웹 기능

sprint-boot-starter-web 라이브러리 추가시 웹서버와 연결

원래 스프링 부트는 AnnotationConfigApplicationContext 기반으로 애플리케이션 구동 

웹 라이브러리 추가시 -> AnnotationConfigServletWebServerApplicationContext 기반



#### 문제

컨테이너에서 컨트롤러 주입 -> Scope가 Request인 객체를 필드로 가지고 있는 컨트롤러도 주입하려함

-> 근데 Request 요청이 와야지만 생성됨 -> BeanCreation 오류



#### 해결 - Provider

ObjectProvider의 getObject()를 통해 주입받아 사용하기 (이 시점에 생성됨)

Request Scope가 올때까지 생성을 지연할 수 있음.

이때 Controller와 Service 로직 둘다 코드넣기 너무 귀찮음.



#### 해결 - Proxy

`proxyMode = ScopedProxyMode.TARGET_CLASS` 넣기, 인터페이스면 `INTERFACE`로

얘가 처음에 가짜 프록시 클래스를 만들어서 주입함 -> 실제로 Request가 오면 그제서야 제대로 동작할 수 있게.



가짜 프록시는 실제 객체를 찾는 방법을 알고 있음 -> 클라이언트가 메소드를 호출하면 가짜 프록시 객체의 메소드를 호출 -> 가짜 프록시 객체가 request 스코프의 진짜 메소드를 호출 

가짜 프록시 객체는 원본을 상속받아서 만들어짐 = 우리는 구분을 못함 (다형성)



이러한 방법으로 마치 싱글톤을 사용하는 것처럼 편리하게 사용 가능

