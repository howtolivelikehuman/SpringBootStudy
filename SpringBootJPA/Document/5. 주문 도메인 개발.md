여러 연관관계의 생성은 별도의 생성 메소드가 있는게 좋음

-> 생성할 거를 바꿀 때 이부분만 바꾸면 되기 때문.



* 보통 CASCADE 옵션 사용

  1. LifeCycle 동일하게 관리
  2. private Owner인 경우

  만약 다른데서 많이쓰는거면 안됨

  



* 생성자 다른 스타일 막는 법

  > protected로 생성자 만들어놓기
  >
  > @NoArgsConstructor(access = AccessLevel.PROTECTED)



SQL을 직접 다루는 스타일은 만약 데이터 바꾸면 일일히 모든 테이블에 다시 UDPATE 쿼리를 날려서 갱신해야 함 -> 서비스 계층에서 로직을 짜는 **트랜잭션 스크립트 패턴**을 써야 함.

JPA를 사용하는 경우, dirty checking이라 해서 얘가 알아서 다 해줌.

-> 엔티티에 핵심 비즈니스를 넣는 **도메인 모델 패턴**

한 프로젝트 안에서 두 패턴이 양립함. 문맥에 따라 쓰기