## 2. 지연 로딩, 조회 성능 최적화

xToOne 관계에서 효율적으로 하는 법

Order - Member (M:1)

Order - Delivery (1:1)



Order에 - Member, Delivery있음 (양방향 연관관계)

#### 1. DTO를 직접 노출

````java
public List<Order> ordersV1(){
        List<Order> all = orderRepository.findAllByString(new OrderSearch());
        return all;
}
````



그냥 DTO를 사용한 경우 

문제1)

> JSON을 만들면서 -> Order에 가니깐 Member가 있음
>
> Member에 가니깐 Order가 또 있음 -> 무한루프

해결책) 양방향중에 하나를 다 JsonIgnore 걸어야 함



문제2)

> Order를 가지고 옴 -> Order에 있는 Member는 지연로딩
>
> = Member를 찾을때 그제서야 DB에서 가져오는거임
>
> 그전까지 Hibernate에서 ProxyMember를 가짜로 넣어둠
>
> (ByteBuddy 라이브러리) 

해결책) 지연 로딩인 경우에는 Hibernate 5module사용

-> Order만 가져옴



물론 Hibernate5Moudle에 옵션 박아서 지연로딩 안 할수도 있음

`configure(Hibernate5Moduel.Feature.FORCE_LAZY_LOADING, true)`

-> 근데 그럼 내가 원하지 않는 애 다 가져옴

-> JsonIgnore해야함 -> 원하는건 또 안됨.. -> API스펙바뀜.. -> 무한루프



그럼 이런식으로 강제로 조회해서 지연로딩을 깨는 경우

````java
 for (Order order : all) {
     		//getMember()까지 프록시, getName할때 가져옴
            order.getMember().getName();
            order.getDelivery().getStatus();
 }
````

이 방식도 문제 -> Member에 모든 엔티티를 다 노출시킴

여하튼 API 스펙은 단순하고 쓸모있는것만 노출



또 지연로딩이 이렇게 문제가 있다고 -> 즉시로딩으로 변경

JPQL이랑 비교했을때는 성능상 문제가 없음

> jpql에서도 어차피 findAll로 가져오는과정이 Order가져오고 없으면 더가져오고.. 이래서

근데 즉시로딩은 다른 api에서 문제. 성능 튜닝을 할 수 없음.



#### 2. 엔티티를 DTO로 변환



