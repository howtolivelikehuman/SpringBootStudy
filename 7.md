주입할 스프링 빈이 없어도 동작해야 할 때가 있음 

@Autowired(required = true) 면 자동 주입 대상 없어서 오류



@Autowired(required = false)-> 의존관계 없을 때 메소드 자체가 아예 안됨

@Nullable -> 없으면 null 입력

Optional< > -> 없으면 Optional.empty



#### 생성자 주입 권장

요새는 생성자 주입 권장.



1. 불변

   보통 DI는 한번 일어나면 끝날때까지 일어나면 안됨 (대부분은 오히려 변경하면 안됨)

   수정자 주입 할꺼면 set을 public으로 열어버려야 함 -> 누군가의 실수로 변경 가능

   

2. 누락

   순수한 자바 코드에 대해 테스트코드를 짜고 싶을때 수정자로 할 경우 > 

   수정자 주입을 사용할 때 -> 필드에 대해 nullpointexception 발생가능성

   테스트 짜는 입장에서는 의존관계가 눈에 들어오지 않기 때문.

   하지만 생성자 주입시 컴파일 오류로 알아낼 수 있음

   

3. Final 키워드 사용 가능

   생성자에서만 값을 세팅할 수 있음 -> 바꾸려 하면 컴파일 오류 발생

   그리고 누락시에 컴파일 오류 발생해줌

   나머지 주입 방식은 생성자 이후 호출 -> final 못씀



디폴트로 생성자 쓰다가, 필수가 아닌 경우 (옵션) 이때 수정자 주입 하기

필드 주입은 쓰지 말기!



**컴파일 오류가 세상에서 제일 좋은 오류**



#### 롬복, 최신 트렌드

막상 개발 해보면 99% 불변 -> final을 사용하게 됨

근데 생성자 만들기, 값 대입 코드 (this.....) 이거 하기 너무너무 귀찮음



@RequiredArgsConstructor

-> final 붙은 필드를 모두 파라미터로 하는 생성자를 자동으로 만들어줌

깔끔하게 코드 가능



#### 빈이 두개 이상 중복되는 경우



1. @Autowired에 필드명 매칭

   여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭

   파라미터 이름을 맞춰주기

   

2. @Qualifier 끼리 매칭 (빈 이름)

   @Qualifier로 매칭하기 -> 만약 매칭할 거를 못찾으면 어떻게 될까?

   그럼 이 이름의 스프링 빈을 추가로 찾으려고 노력 -> 이래도 없으면 예외

   빈 직접 등록시에도 동일하게 사용 가능

   * 모든 코드에 Qualifier 붙여야 함 (귀찮음)

   * 엄청 헷갈리니깐 Qualifier 쓰는 애들끼리만 명확하게 쓰기

   

3. @Primary 사용

   * 제일 자주 씀 -> @Primary가 제일 먼저 되게

   ex) 메인DB (90% 사용) - 보조DB (10%) -> 이때 메인DB 쓰는 코드에 @Primary로 쓰자

   보조DB 쓰고 싶을때는 Qualifier 쓰자

   둘이 겹쳤을 때 우선순위는 Qualifier가 더 높음. (Primary는 디폴트처럼 동작)



#### Annotation 만들기

@Qualifier("abc") ->이러면 문자열이라 타입 체크가 힘듦

@Annotation 만들어서 거기에 어노테이션들 합체하고 그거 쓰기.



#### 조회한 빈이 모두 필요할때 List, Map

Map을 이용해서 이름을 key 값으로 원하는 정책을 선택할 수 있게 해줌.